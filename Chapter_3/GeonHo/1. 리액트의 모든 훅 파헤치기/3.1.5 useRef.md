# 3.1.5 useRef

### useRef와 useState의 차이점

useRef는 useState처럼 렌더링이 일어나도 state를 저장한다는 공통점이 있지만, 명확한 차이점이 있다.

- 반환값의 current로 접근 및 변경이 가능.
- 그 값이 변하더라도 렌더링이 발생되지 않는다.

<br>

### useRef는 왜 필요할까 ?

우선, 아래 코드를 살펴보자.

```js
let value = 0;

const Component = () => {
    const handleClick = () => {
        value += 1;
    }
    ...
}
```

위 코드는 몇가지 단점이 있다. <br>

- 컴포넌트가 아직 렌더링되지 않아도 value가 존재하며, 이는 메모리에 불필요한 값을 갖게한다.
- Component가 여러번 생성된다면, 각 Component는 모두 동일한 value를 가리키게 된다.

useRef는 위 2가지 문제를 모두 극복할 수 있는 리액트식 접근법이다.

<br>

useRef를 사용할 수 있는 유용한 경우는 렌더링을 발생시키지 않고 원하는 상태값을 저장할 수 있다는 특징이다.<br>
이를 활용하여 usePrevious()같은 훅을 구현할 수 있다.

```jsx
function usePrevious(value) {
  const ref = useRef(); // 최초 렌더링 시 undefined

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

function Component() {
  const [counter, setCounter] = useState(0);
  const prevCounter = usePrevious(counter);

  const handleClick = () => {
    setCounter((prev) => prev + 1);
  };

  return (
    <button onClick={handleClick}>
      {counter} {prevCounter}
    </button>
  );
}

/*
    결과
    0 undefined
    1 0
    2 1
    3 2
*/
```

위 코드의 동작 원리에 대해 생각해보자. <br>

```jsx
const prevCounter = usePrevious(counter);
```

1. 위 코드가 실행되면 usePrevious 내부의 ref는 useRef에 의해 undefined를 할당받는다.<br>
2. useEffect 훅은 컴포넌트가 렌더링된 후에 실행된다. (이는 컴포넌트가 화면에 그려진 직후에 비동기적으로 실행되는 사이드 이펙트를 처리하기 위함.) <br>
3. undefined를 리턴하고 난 후, useEffect 내부 로직이 실행되어 ref.current 값을 업데이트한다.

이렇듯 개발자가 원하는 시점에서 렌더링에 영향을 미치지 않고 보관해 두고 싶을때 유용하게 사용할 수 있다.

 <br>

### useRef는 어떻게 구현되어있을까?

```jsx
// Preact 기준
function useRef(initialValue) {
  return useMemo(() => ({ current: initialValue }), []);
}
```

**위와 같이 렌더링이 되어도 변하지 않게끔 useMemo에 넣어두었다.** <br>
**배열에 값을 저장하고, 디펜던시 어레이에 아무것도 넣지 않아 각 렌더링마다 동일한 객체를 가리키게 될 것이다.**
